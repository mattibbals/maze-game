{"version":3,"sources":["utilities/map/index.jsx","utilities/player/index.jsx","components/overHeadView/index.jsx","components/maze/index.js","utilities/collectible/index.jsx","App.js","serviceWorker.js","index.js"],"names":["createMazeGridPims","width","height","MazeCell","northWall","eastWall","southWall","westWall","this","checkWall","wallListIdx","cellToCheck","wallList","x","z","visitedCells","some","cell","splice","dir","push","mazeGrid","i","Array","j","startX","Math","floor","random","startZ","length","console","log","displayMazeGrid","playerObj","collectables","player","gridX","gridY","direction","getCellClasses","cellClasses","displayMazeGridColumns","row","rowIdx","map","cellIdx","key","className","cellContent","forEach","collectable","y","getCellContent","displayMazeGridRows","placeWallGraphics","scene","wallGeometry","THREE","wallMaterial","placeWall","wall","position","rotation","PI","add","mazeRow","rowCount","mazeCell","colCount","doKeyDown","event","keynum","window","keyCode","which","playerInput","left","up","right","down","doKeyUp","OverHeadView","props","style","paddingLeft","float","paddingTop","MAP","clear","Maze","useEffect","React","playerDirection","playerState","currentDirection","turningArc","walkingDistance","last_update","Date","now","mazeCanvas","document","getElementById","overHeadView","renderer","canvas","camera","number","collectableGeometry","collectableMaterial","color","totalCollectibles","collectablesCollected","unique","action","alert","obj","COLLECTABLE","collectableObject","addEventListener","evt","PLAYER","playerPointLight","set","render","requestAnimationFrame","deltaTime","index","remove","ReactDOM","removeEventListener","id","App","Boolean","location","hostname","match","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.c9d05b42.chunk.js","sourcesContent":["import * as THREE from \"three\";\nimport React from 'react';\n\nexport const NORTH = 100;\nexport const EAST = 101;\nexport const WEST = 102;\nexport const SOUTH = 103;\n\nexport const getMazeGridObj = (scene) => {\n //  const mazeGrid = createMazeGrid();\n const mazeGrid = createMazeGridPims(20,20);\n    placeWallGraphics(scene, mazeGrid);\n    return mazeGrid;\n}\n\nexport const createMazeGrid = () => {\n    function MazeCell(northWall, eastWall, southWall, westWall) {\n        this.northWall = northWall;\n        this.eastWall = eastWall;\n        this.southWall = southWall;\n        this.westWall = westWall;\n      }\n      const mazeGrid = [Array(3), Array(3), Array(3)];\n      mazeGrid[0][0] = new MazeCell(true, false, false, true);\n      mazeGrid[0][1] = new MazeCell(true, false, true, false);\n      mazeGrid[0][2] = new MazeCell(true, true, false, false);\n      mazeGrid[1][0] = new MazeCell(false, true, false, true);\n      mazeGrid[1][1] = new MazeCell(true,true,true,true);\n      mazeGrid[1][2] = new MazeCell(false,true,false,true);\n      mazeGrid[2][0] = new MazeCell(false, false, true, true);\n      mazeGrid[2][1] = new MazeCell(true,false,true,false);\n      mazeGrid[2][2] = new MazeCell(false,true,true,false);\n      return mazeGrid;\n}\n\nexport const createMazeGridPims = (width, height) => {\n   //  console.log(\"calling createMazeGridPims\");\n     function MazeCell(northWall, eastWall, southWall, westWall) {\n        this.northWall = northWall;\n        this.eastWall = eastWall;\n        this.southWall = southWall;\n        this.westWall = westWall;\n      }\n      function checkWall(wallListIdx) {\n   //      console.log(\"mazeGrid = \", mazeGrid);\n        let cellToCheck = {};\n  //      console.log(\"wallList[\" + wallListIdx + \"] = \", wallList[wallListIdx]);\n        switch(wallList[wallListIdx]['dir']) {\n           case NORTH :\n              cellToCheck = {x: wallList[wallListIdx].x, z:wallList[wallListIdx].z+1};\n              break;\n           case SOUTH : \n              cellToCheck = {x: wallList[wallListIdx].x, z:wallList[wallListIdx].z-1};\n              break;\n           case EAST :\n              cellToCheck = {x: wallList[wallListIdx].x+1, z:wallList[wallListIdx].z};\n              break;\n           case WEST :\n           default :\n              cellToCheck = {x: wallList[wallListIdx].x-1, z:wallList[wallListIdx].z};\n              break;\n        }\n   //     console.log(\"cell to check = \", cellToCheck);\n        if (((cellToCheck.x < 0)||(cellToCheck.x >= width))||((cellToCheck.z < 0)||(cellToCheck.z >= height))) {\n    //       console.log(\"OUT OF BOUNDS\");\n           wallList.splice(wallListIdx, 1);\n           return;\n        }\n        if (visitedCells.some((cell) => ((cell.x === cellToCheck.x) && (cell.z === cellToCheck.z)))) {\n     //      console.log(\"VISITED ALREADY\");\n           wallList.splice(wallListIdx, 1);\n           return;\n        } else {\n           if (wallList[wallListIdx].dir === EAST) \n           {\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: SOUTH});\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: EAST});\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: WEST});\n              mazeGrid[cellToCheck.x][cellToCheck.z].northWall = false;\n              mazeGrid[wallList[wallListIdx].x][wallList[wallListIdx].z].southWall = false;\n           }\n           if (wallList[wallListIdx].dir === WEST) {\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: NORTH});\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: EAST});\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: WEST});\n              mazeGrid[cellToCheck.x][cellToCheck.z].southWall = false;\n              mazeGrid[wallList[wallListIdx].x][wallList[wallListIdx].z].northWall = false;\n           }\n           if (wallList[wallListIdx].dir === SOUTH) \n           {\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: NORTH});\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: SOUTH});\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: WEST});\n              mazeGrid[cellToCheck.x][cellToCheck.z].eastWall = false;\n              mazeGrid[wallList[wallListIdx].x][wallList[wallListIdx].z].westWall = false;\n           }\n           if (wallList[wallListIdx].dir === NORTH) {\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: NORTH});\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: SOUTH});\n              wallList.push({x:cellToCheck.x, z:cellToCheck.z, dir: EAST});\n              mazeGrid[cellToCheck.x][cellToCheck.z].westWall = false;\n              mazeGrid[wallList[wallListIdx].x][wallList[wallListIdx].z].eastWall = false;\n           }\n           visitedCells.push({x:cellToCheck.x, z:cellToCheck.z});\n           wallList.splice(wallListIdx, 1);\n   //        console.log(\"mazeGrid = \", mazeGrid);\n           return mazeGrid;\n        }\n  \n      }\n      //const mazeGrid = [Array(width), Array(height)];\n      const mazeGrid = [];\n      const visitedCells = [];\n      for (let i=0; i< width; i++) {\n        mazeGrid.push(Array(height));\n        visitedCells.push(Array(height));\n      }\n      const wallList = [];\n      for (let i = 0; i<width; i++) {\n         for (let j = 0; j< height; j++) {\n           mazeGrid[i][j] = new MazeCell(true,true,true,true);\n           visitedCells[i][j] = false;\n         }\n      }\n  //    console.log(\"initial MazeGrid = \", mazeGrid);\n      const startX = Math.floor(Math.random() * width);\n      const startZ = Math.floor(Math.random() * height);\n      visitedCells[startX][startZ] = true;\n      wallList.push({x:startX, z:startZ, dir: NORTH});\n      wallList.push({x:startX, z:startZ, dir: SOUTH});\n      wallList.push({x:startX, z:startZ, dir: EAST});\n      wallList.push({x:startX, z:startZ, dir: WEST});\n  \n      do {\n   //      console.log(\"********************************\");\n    //     console.log(\"wallList.length = \", wallList.length);\n         let currentWallListIdx = Math.floor(Math.random() * (wallList.length - 1));\n         checkWall(currentWallListIdx);\n      } while ((wallList.length > 0));\n      console.log(\"mazeGrid = \", mazeGrid);\n      return mazeGrid;\n  }\n\nexport const displayMazeGrid = (mazeGrid, playerObj, collectables) => {\n   const { player : {gridX, gridY, direction} } = playerObj;\n   const getCellContent = (rowIdx, cellIdx) => {\n      let cellContent;\n      if ((gridX === rowIdx)&&(gridY === cellIdx)) {\n         switch(direction) {\n            case NORTH :\n               cellContent = '\\u2191';\n               break;\n            case SOUTH :\n               cellContent = '\\u2193';\n               break;\n            case EAST :\n               cellContent = '\\u2192';\n               break;\n            case WEST :\n               cellContent = '\\u2190';\n               break;\n            default :\n               break;\n         }\n      } else {\n         collectables.forEach(collectable => {\n            if ((collectable.x === rowIdx)&&(collectable.y === cellIdx)) {\n               cellContent = '\\u25A0';\n            }\n         });\n      }\n      return <span>{cellContent}</span>\n   }\n   const getCellClasses = (cell) => {\n      let cellClasses = \"\"\n      if (cell.eastWall) {\n         cellClasses += \"east_wall\"\n      }\n      if (cell.westWall) {\n         cellClasses += \" west_wall\"\n      }\n      if (cell.northWall) {\n         cellClasses += \" north_wall\"\n      }\n      if (cell.southWall) {\n         cellClasses += \" south_wall\"\n      }\n      return cellClasses;\n   };\n   const displayMazeGridColumns = (row, rowIdx) => row.map((cell, cellIdx) => <div key={cellIdx} className={`map_cell ${getCellClasses(cell)}`}>{getCellContent(rowIdx, cellIdx)}</div>);\n   const displayMazeGridRows = mazeGrid => mazeGrid.map((row, rowIdx) => <div key={rowIdx} className={'map_row'}>{displayMazeGridColumns(row, rowIdx)}</div>);\n   return <div className={'map_container'}>{displayMazeGridRows(mazeGrid)}</div>\n   \n}\n\nexport const placeWallGraphics = (scene, mazeGrid) => {\n    const wallGeometry = new THREE.PlaneGeometry( 1, 0.5 );\n    const wallMaterial = new THREE.MeshStandardMaterial( );\n    const placeWall = (x,y,direction) => {\n        var wall = new THREE.Mesh( wallGeometry, wallMaterial );\n        wall.position.z = y*1;\n        wall.position.x = x*1;\n        if(direction === 'n'){\n           wall.position.z -= 0.5;\n        }\n        else if(direction === 'e'){\n           wall.position.x += 0.5;\n           wall.rotation.y = -Math.PI/2;\n        }\n        else if(direction === 's'){\n           wall.position.z += 0.5;\n           wall.rotation.y = Math.PI;\n        }\n        else if(direction === 'w'){\n           wall.position.x -= 0.5;\n           wall.rotation.y = Math.PI/2;\n        }\n        else{\n           return false;\n        }\n        scene.add(wall);\n     }\n    mazeGrid.forEach(function(mazeRow, rowCount){\n       mazeRow.forEach(function(mazeCell, colCount){\n          if(mazeCell.northWall)\n            placeWall(colCount, rowCount, 'n');\n          if(mazeCell.eastWall)\n            placeWall(colCount, rowCount, 'e');\n          if(mazeCell.southWall)\n             placeWall(colCount, rowCount, 's');\n          if(mazeCell.westWall)\n             placeWall(colCount, rowCount, 'w');\n       });\n    });\n \n\n}\n\nexport const validMove = (mazeGrid, x, y, direction) => {\n    if(direction === NORTH)\n    {\n       return !mazeGrid[x][y].northWall;\n    }\n    else if(direction === EAST)\n    {\n       return !mazeGrid[x][y].eastWall;\n    }\n    else if(direction === SOUTH)\n    {\n       return !mazeGrid[x][y].southWall;\n    }\n    else if(direction === WEST)\n    {\n       return !mazeGrid[x][y].westWall;\n    }\n    return false;\n  }","import * as MAP from '../../utilities/map';\nimport * as COLLECTABLE from '../../utilities/collectible'\n\nexport const WAITING = 1;\nexport const TURNING_RIGHT = 2;\nexport const TURNING_LEFT = 3;\nexport const MOVING_FORWARD = 4;\n\nexport const getPlayerObj = () => {\n    \n    return {\n        startX: 0,\n        startZ: 0,\n        playerDirection: MAP.NORTH,\n        playerState: WAITING,\n        currentDirection: 0,\n        player: {gridX:0, gridY:0, direction: MAP.NORTH},\n        turningArc: 0,\n        walkingDistance: 0,\n        last_update: Date.now(),\n        playerInput: {right:0,left:0,up:0,down:0}\n    };\n}\n\nexport const doKeyDown = (event, playerObj) => {\n    let keynum;\n \n    if(window.event){ //Browser is IE\n       keynum = event.keyCode;\n    }\n    else{\n       keynum = event.which;\n    }\n \n    if(keynum === 37){\n       playerObj.playerInput.left = 1;\n    }\n    else if(keynum === 38){\n       playerObj.playerInput.up = 1;\n    }\n    else if(keynum === 39){\n       playerObj.playerInput.right = 1;\n    }\n    else if(keynum === 40){\n       playerObj.playerInput.down = 1;\n    }\n }\n \n export const doKeyUp = (event, playerObj) => {\n    let keynum;\n    \n    if(window.event){ //Browser is IE\n       keynum = event.keyCode;\n    }\n    else{\n       keynum = event.which;\n    }\n \n    if(keynum === 37){\n       playerObj.playerInput.left = 0;\n    }\n    else if(keynum === 38){\n       playerObj.playerInput.up = 0;\n    }\n    else if(keynum === 39){\n       playerObj.playerInput.right = 0;\n    }\n    else if(keynum === 40){\n       playerObj.playerInput.down = 0;\n    }\n }\n\nexport const doPlayerMove = (\n    mazeGrid, \n    playerObj,\n    deltaTime,\n    collectables,\n    scene\n    ) => {\n\n\n    if(playerObj.playerState === WAITING) {\n        if(playerObj.playerInput.left === 1) {\n          playerObj.playerState = TURNING_LEFT;\n          switch(playerObj.playerDirection){\n            case MAP.NORTH:\n              playerObj.playerDirection = MAP.WEST;\n               break;\n            case MAP.EAST:\n              playerObj.playerDirection = MAP.NORTH;\n               break;\n            case MAP.SOUTH:\n              playerObj.playerDirection = MAP.EAST;\n               break;\n            case MAP.WEST:\n            default:\n              playerObj.playerDirection = MAP.SOUTH;\n               break;\n         }\n         playerObj.player.direction = playerObj.playerDirection;\n        }\n        else if(playerObj.playerInput.right === 1) {\n          playerObj.playerState = TURNING_RIGHT;\n          switch(playerObj.playerDirection){\n            case MAP.NORTH:\n              playerObj.playerDirection = MAP.EAST;\n               break;\n            case MAP.EAST:\n              playerObj.playerDirection = MAP.SOUTH;\n               break;\n            case MAP.SOUTH:\n              playerObj.playerDirection = MAP.WEST;\n               break;\n            case MAP.WEST:\n            default:\n              playerObj.playerDirection = MAP.NORTH;\n               break;\n         }\n         playerObj.player.direction = playerObj.playerDirection;\n        } else if(playerObj.playerInput.up && MAP.validMove(mazeGrid, playerObj.player.gridX, playerObj.player.gridY, playerObj.player.direction)){\n          playerObj.walkingDistance = 0;\n          playerObj.startX = playerObj.camera.position.x;\n          playerObj.startZ = playerObj.camera.position.z;\n          playerObj.playerState = MOVING_FORWARD;\n          switch(playerObj.playerDirection){\n            case MAP.NORTH:\n               playerObj.player.gridX--;\n               break;\n            case MAP.EAST:\n               playerObj.player.gridY++;\n               break;\n            case MAP.SOUTH:\n               playerObj.player.gridX++;\n               break;\n            case MAP.WEST:\n            default:\n               playerObj.player.gridY--;\n               break;\n         }\n       }\n      }\n\n\n      if(playerObj.playerState === TURNING_LEFT){\n        playerObj.turningArc += Math.PI/2 * deltaTime/1000;\n        if(playerObj.turningArc >= Math.PI/2){\n          playerObj.turningArc = Math.PI/2;\n          playerObj.currentDirection = playerObj.currentDirection + playerObj.turningArc;\n          playerObj.turningArc = 0;\n          playerObj.playerState = WAITING;\n        }\n        playerObj.camera.rotation.y = playerObj.currentDirection + playerObj.turningArc;\n      }\n      \n      if(playerObj.playerState === TURNING_RIGHT){\n        playerObj.turningArc += Math.PI/2 * deltaTime/1000;\n        if(playerObj.turningArc >= Math.PI/2){\n          playerObj.turningArc = Math.PI/2;\n          playerObj.currentDirection = playerObj.currentDirection - playerObj.turningArc;\n          playerObj.turningArc = 0;\n          playerObj.playerState = WAITING;\n        }\n        playerObj.camera.rotation.y = playerObj.currentDirection - playerObj.turningArc;\n      }\n    if(playerObj.playerState === MOVING_FORWARD) {\n        playerObj.walkingDistance += 1 * deltaTime/1000;\n\n        if(playerObj.walkingDistance >= 1){\n            playerObj.walkingDistance = 1;\n            playerObj.playerState = WAITING;\n            COLLECTABLE.processCollectableCollisions(playerObj.player.gridX, playerObj.player.gridY,collectables,scene);\n        }\n        switch(playerObj.playerDirection){\n            case MAP.NORTH:\n              playerObj.camera.position.z = playerObj.startZ - playerObj.walkingDistance;\n              break;\n            case MAP.EAST:\n              playerObj.camera.position.x = playerObj.startX + playerObj.walkingDistance;\n              break;\n            case MAP.SOUTH:\n              playerObj.camera.position.z = playerObj.startZ + playerObj.walkingDistance;\n              break;\n            case MAP.WEST:\n            default:\n              playerObj.camera.position.x = playerObj.startX - playerObj.walkingDistance;\n              break;\n        }\n      }\n}","import React from 'react';\nimport * as MAP from '../../utilities/map';\n\nconst OverHeadView = props => {\n    const {  playerObj, mazeGrid, collectables } = props;\n    const { player : { gridX, gridY, direction }} = playerObj;\n    return (\n        <>\n            <div style={{paddingLeft: \"200px\"}}>PLAYER POSITION ({`${gridX}, ${gridY}`})</div>\n            <div style={{paddingLeft: \"200px\"}}>PLAYER DIRECTION ({`${direction}`})</div>\n            <div style={{paddingLeft: \"200px\"}}>NORTH ({MAP.NORTH})</div>\n            <div><div style={{float: \"left\", paddingTop: \"150px\"}}>WEST ({MAP.WEST})</div><div style={{float: \"left\"}}>{MAP.displayMazeGrid(mazeGrid, playerObj, collectables)}</div><div style={{float: \"left\", paddingTop: \"150px\"}}>EAST ({MAP.EAST})</div></div>\n            <div style={{clear: \"both\", paddingLeft: \"200px\"}}>SOUTH ({MAP.SOUTH})</div>\n        </>\n    );\n}\n\nexport default OverHeadView;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport * as THREE from \"three\";\nimport '../../App.css';\nimport * as MAP from '../../utilities/map';\nimport * as PLAYER from '../../utilities/player';\nimport * as COLLECTABLE from '../../utilities/collectible'\nimport OverHeadView from '../overHeadView'\n\n\nconst scene = new THREE.Scene();\nconst mazeGrid = MAP.getMazeGridObj(scene);\n\nfunction Maze() {\n\n  const { useEffect, } = React\n\n  const playerObj = PLAYER.getPlayerObj();\n\n  useEffect(() => {\n\n    const mazeCanvas = document.getElementById(\"mazeCanvas\");\n    const overHeadView = document.getElementById(\"overHeadView\");\n\n    const renderer = new THREE.WebGLRenderer({ canvas: mazeCanvas });\n    playerObj.camera = new THREE.PerspectiveCamera( 75, mazeCanvas.width/mazeCanvas.height, 0.1, 1000 );\n\n    const collectables = COLLECTABLE.createCollectiblesList(5, mazeGrid);\n    COLLECTABLE.placeCollectableGraphics(scene, collectables);\n\n    window.addEventListener(\"keydown\", function(evt) { PLAYER.doKeyDown(evt, playerObj) }, false);\n    window.addEventListener(\"keyup\", function(evt) { PLAYER.doKeyUp(evt, playerObj) }, false);\n\n\n    const playerPointLight = new THREE.PointLight();\n    playerPointLight.position.set( 0, 0, 0 );\n    scene.add( playerPointLight );\n\n    var render = function () {\n\n      requestAnimationFrame( render );\n\n      const now = Date.now();\n      let deltaTime = now - playerObj.last_update;\n      playerObj.last_update = now;\n\n      PLAYER.doPlayerMove(\n        mazeGrid, \n        playerObj,\n        deltaTime,\n        collectables,\n        scene\n        );\n\n        playerPointLight.position.x = playerObj.camera.position.x;\n        playerPointLight.position.y = playerObj.camera.position.y;\n        playerPointLight.position.z = playerObj.camera.position.z;\n\n        COLLECTABLE.doCollectablesMove(collectables, deltaTime);\n \n  //      console.log(\"coordinates \", playerObj.player.gridX, playerObj.player.gridY);\n  //      console.log(\"playerDirection \", playerObj.playerDirection);\n\n/*   console.log(\"walkingDistance\", walkingDistance.current);\n  console.log(\"playerInput\", playerObj.playerInput);\n  console.log(\"turningArc\", turningArc.current);\n  console.log(\"currentDirection\", currentDirection.current);\n  console.log(\"plauerDirection\", playerDirection.current);\n  console.log(\"camera y\", playerObj.camera.rotation.y);\n  console.log(\"playerState\", playerState.current);\n  console.log('*************************************'); */\n  //    overHeadView.innerHTML = <OverHeadView mazeGrid={mazeGrid} playerObj={playerObj} />;\n\n      ReactDOM.render(\n        <OverHeadView mazeGrid={mazeGrid} playerObj={playerObj} collectables={collectables} />,\n        overHeadView\n      )\n\n      renderer.render(scene, playerObj.camera);\n   };\n\n   render();\n\n   return function cleanup() {\n    window.removeEventListener(\"keydown\", function(evt) { PLAYER.doKeyDown(evt, playerObj) }, false);\n    window.removeEventListener(\"keyup\", function(evt) { PLAYER.doKeyUp(evt, playerObj) }, false);\n   }\n\n  });\n\n  return (\n    <>\n      <canvas id=\"mazeCanvas\" width=\"600\" height=\"450\" />\n      <div id=\"overHeadView\" />\n    </>\n    )\n}\n\nexport default Maze;\n","import * as THREE from \"three\";\n\nexport const createCollectiblesList = (number, mazeGrid) => {\n\n    const collectableGeometry = new THREE.BoxGeometry( 0.25, 0.25, 0.25 );\n    const collectableMaterial = new THREE.MeshStandardMaterial( {color: 0x000088} );\n\n    const totalCollectibles = number;\n    let collectablesCollected = 0;\n\n    var collectables = [];\n\n    var width = mazeGrid[0].length;\n    var height = mazeGrid.length;\n\n    for(var i=0; i < number; i++){\n      var x;\n      var y;\n      var unique = false; //Set loop flag up so the loop runs at least once\n\n      while(!unique){\n         x = Math.floor(Math.random()*width);\n         y = Math.floor(Math.random()*height);\n         unique = true; //Assume the random coordinate is empty\n         collectables.forEach(function(collectable){\n            if(collectable.x == x && collectable.y == y){\n               unique = false; //Oops! Square already has a collecatble. Reset flag so we loop again\n            }\n         });\n      }\n\n      //If we've gotten here the loop must have found an empty square and exited\n      collectables.push({\n         x:x, \n         y:y, \n         action:function(){\n            collectablesCollected++;\n            alert(\"You have picked up \"+collectablesCollected+\" out of \"+totalCollectibles+\" collectables\");\n            if(collectablesCollected == totalCollectibles){\n               alert(\"Congratulations! You won the game! Refresh the page to play again.\");\n            }\n         },\n         obj: new THREE.Mesh(collectableGeometry, collectableMaterial)\n      });\n   }\n \n    return collectables;\n }\n\nexport const  placeCollectableGraphics = (scene, collectables) => {\n    collectables.forEach(collectable => {\n       const { obj : collectableObject } = collectable;\n       collectableObject.position.z = collectable.x;\n       collectableObject.position.x = collectable.y;\n       scene.add(collectableObject);\n    });\n }\n\n export const doCollectablesMove = (collectables, deltaTime) => {\n    //Make our collectables spin\n    collectables.forEach(collectable => {\n    const { obj : collectableObject } = collectable;\n    collectableObject.rotation.x += 2 * deltaTime/1000;\n    collectableObject.rotation.y += 2 * deltaTime/1000;\n    });  \n }\n\n export const processCollectableCollisions = (x, y,collectables,scene) => {\n    collectables.forEach(function(collectable,index){\n       if(collectable.x == x && collectable.y == y){\n          collectable.action(); //Run the object's event\n          scene.remove(collectable.obj); //Remove graphics from scene\n          collectables.splice(index,1); //Remove collectable from list\n       }\n    });\n }","import React from 'react';\n//import SpinningCube from './components/spinningCube'\nimport Maze from './components/maze'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n   {/*  <SpinningCube />*/} \n    <Maze />\n\n      \n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}